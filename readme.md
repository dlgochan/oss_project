# gdb tutorial



#### 제작 동기

주변 동기들이나 다른 학생들을 보면 프로그램을 제작하고 실행 과정에서 에러가 났을 때 대부분 printf를 통해서 각 변수의 값들을 단계별로 출력해보고 런타임 에러가 나면 순차적으로 printf를 실행해보면서 에러가 난 곳을 찾아가는 것을 많이 보았다.

 디버깅하는 과정을 학교에서 제대로 가르쳐준 적도 없고 IDE마다 방법도 다르고 디버깅이랑 용어도 광범위하게 사용이 되다보니 알아볼 의욕도 생기지 않아서 별 고민없이 printf로 계속 디버깅을 해왔던 것 같다. 하지만 gcc -g 옵션으로 심볼을 추가하고 gdb로 디버깅을 하게 되면 매우 적은 노력으로 확실하게 얻는 효과가 더 크다.

cli를 어려워할 수도 있고 새로운 tool에 대한 거부감도 있을 수 있기 때문에 최대한 거부감이 없도록 어셈블리어나 레지스터 메모리에 대한 설명은 제외하고 자기가 직접 만드는 프로그램을 디버깅할 때 간단하게 gdb를 사용하여 해결할 수 있는 방법을 제시했다.

#### 애로사항

continue 명령어를 cont라고 사용하는 사람도 있고 c 로 사용하는 사람도 있는 등 같은 동작을 하는 명령어를 다 다르게 써서 최대한 모호한 부분을 없애기 위해 한글자 명령어 대신 직관적으로 무엇을 의미하는 지 알 수있을 정도의 명령어로 선정하였다. 

디버거를 설명하기 이전에 실행파일의 각 세그먼트 영역이나 어셈블리어 레지스터 값 pc, eip, esp 등 실제 디버거에서 많이 활용하는 부분을 설명하려면 2시간은 걸릴 것 같아서 최대한 디버거에 대한 거부감 없이 가볍게 사용할 수 있도록 심볼을 추가해서 소스코드를 통해 확인할 수 있는 방법만 설명하였다.

ppt로만은 설명이 충분하지 않아서 직접 터미널에서 어떤 식으로 동작하는지 보여주면서 설명하였다.

영상 작업은 익숙하지 않아서 obs를 통해 소스들을 추가하고 녹화하고 추출해서 편집하는 과정들이 많이 힘들었다.



#### 부족한 점

gdb에 다룰 명령어가 매우 많아서 모두 소개를 하지 못했다.

소스코드 단에서 디버깅 뿐만아니라 어셈블리 단에서 심볼이 없는 실행파일을 동적 디버깅을 통해 분석하는 방법 또한 추가되면 좋을 것 같다.

이를 위해선 일단 어셈블리어와 레지스터 용도와 세그먼트 구조를 알고있어야 할 것이다.







## source code

##### ex.c

```c
#include <stdio.h>

int sum(int a, int b){
	return (a+b);
}

int main(){
	int a, b, result;
  scanf("%d %d", &a, &b);
  result = sum(a, b);
  printf("%d\n", result);
  return 0;
}

```





##### segfault.c

```c
#include <stdio.h>
#include <stdlib.h>

int sum(int** arr){
  int sum = 0;
  int i = 0;
  while(i<=5){
	  sum += arr[i][1];
	 	i += 1;
  }
  return sum;
}

int main(){
  int result;
  int* arr[5];
  for(int i=0; i<5; i++){
		arr[i]=(int*)malloc(sizeof(int)*5);
		for(int j=0; j<5; j++){
			arr[i][j] = j;
    }
  }

  result = sum(arr);
  printf("%d\n", result);
  return 0;
}

```

